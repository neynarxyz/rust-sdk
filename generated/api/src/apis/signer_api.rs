/*
 * Farcaster API V2
 *
 * The Farcaster API allows you to interact with the Farcaster protocol. See the [Neynar docs](https://docs.neynar.com/reference) for more details.
 *
 * The version of the OpenAPI document: 2.36.1
 * Contact: team@neynar.com
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for passing parameters to the method [`fetch_authorization_url`]
#[derive(Clone, Debug)]
pub struct FetchAuthorizationUrlParams {
    pub client_id: String,
    pub response_type: models::AuthorizationUrlResponseType,
}

/// struct for passing parameters to the method [`fetch_signers`]
#[derive(Clone, Debug)]
pub struct FetchSignersParams {
    /// A Sign-In with Ethereum (SIWE) message that the user's Ethereum wallet signs. This message includes details such as the domain, address, statement, URI, nonce, and other relevant information following the EIP-4361 standard. It should be structured and URL-encoded.  example:  example.com wants you to sign in with your Ethereum account:\\\\n0x23A...F232\\\\n\\\\nSign in to continue.\\\\n\\\\nURI: example.com\\\\nVersion: 1\\\\nChain ID: 1\\\\nNonce: xyz123\\\\nIssued At: 2021-09-01T14:52:07Z  Note: This is just an example message (So, message is invalid, since we don't want any signers related to NEYNAR_API_DOCS to be exposed).   [Checkout fetch-signers API documentation for more details.](https://docs.neynar.com/docs/fetch-signers-1)
    pub message: String,
    /// The digital signature produced by signing the provided SIWE message with the user's Ethereum private key. This signature is used to verify the authenticity of the message and the identity of the signer.
    pub signature: String,
}

/// struct for passing parameters to the method [`lookup_developer_managed_signer`]
#[derive(Clone, Debug)]
pub struct LookupDeveloperManagedSignerParams {
    pub public_key: String,
}

/// struct for passing parameters to the method [`lookup_signer`]
#[derive(Clone, Debug)]
pub struct LookupSignerParams {
    pub signer_uuid: String,
}

/// struct for passing parameters to the method [`publish_message_to_farcaster`]
#[derive(Clone, Debug)]
pub struct PublishMessageToFarcasterParams {
    pub body: serde_json::Value,
}

/// struct for passing parameters to the method [`register_signed_key`]
#[derive(Clone, Debug)]
pub struct RegisterSignedKeyParams {
    pub register_signer_key_req_body: models::RegisterSignerKeyReqBody,
}

/// struct for passing parameters to the method [`register_signed_key_for_developer_managed_signer`]
#[derive(Clone, Debug)]
pub struct RegisterSignedKeyForDeveloperManagedSignerParams {
    pub register_developer_managed_signed_key_req_body:
        models::RegisterDeveloperManagedSignedKeyReqBody,
}

/// struct for typed errors of method [`create_signer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSignerError {
    Status500(models::ErrorRes),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_authorization_url`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchAuthorizationUrlError {
    Status400(models::ErrorRes),
    Status401(models::ErrorRes),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_signers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSignersError {
    Status400(models::ErrorRes),
    Status401(models::ErrorRes),
    Status500(models::ErrorRes),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`lookup_developer_managed_signer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LookupDeveloperManagedSignerError {
    Status400(models::ErrorRes),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`lookup_signer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LookupSignerError {
    Status400(models::ErrorRes),
    Status403(models::ErrorRes),
    Status404(models::ErrorRes),
    Status500(models::ErrorRes),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`publish_message_to_farcaster`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PublishMessageToFarcasterError {
    Status400(models::ErrorRes),
    Status500(models::ErrorRes),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`register_signed_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RegisterSignedKeyError {
    Status400(models::ErrorRes),
    Status403(models::ErrorRes),
    Status404(models::ErrorRes),
    Status500(models::ErrorRes),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`register_signed_key_for_developer_managed_signer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RegisterSignedKeyForDeveloperManagedSignerError {
    Status400(models::ErrorRes),
    Status500(models::ErrorRes),
    UnknownValue(serde_json::Value),
}

/// Creates a signer and returns the signer status. \\ **Note**: While tesing please reuse the signer, it costs money to approve a signer.
pub async fn create_signer(
    configuration: &configuration::Configuration,
) -> Result<models::Signer, Error<CreateSignerError>> {
    let uri_str = format!("{}/farcaster/signer", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Signer`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Signer`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateSignerError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Fetch authorization url (Fetched authorized url useful for SIWN login operation)
pub async fn fetch_authorization_url(
    configuration: &configuration::Configuration,
    params: FetchAuthorizationUrlParams,
) -> Result<models::AuthorizationUrlResponse, Error<FetchAuthorizationUrlError>> {
    let uri_str = format!("{}/farcaster/login/authorize", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("client_id", &params.client_id.to_string())]);
    req_builder = req_builder.query(&[("response_type", &params.response_type.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthorizationUrlResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthorizationUrlResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FetchAuthorizationUrlError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Fetches a list of signers for a custody address
pub async fn fetch_signers(
    configuration: &configuration::Configuration,
    params: FetchSignersParams,
) -> Result<models::SignerListResponse, Error<FetchSignersError>> {
    let uri_str = format!("{}/farcaster/signer/list", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("message", &params.message.to_string())]);
    req_builder = req_builder.query(&[("signature", &params.signature.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SignerListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SignerListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FetchSignersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Fetches the status of a developer managed signer by public key
pub async fn lookup_developer_managed_signer(
    configuration: &configuration::Configuration,
    params: LookupDeveloperManagedSignerParams,
) -> Result<models::DeveloperManagedSigner, Error<LookupDeveloperManagedSignerError>> {
    let uri_str = format!(
        "{}/farcaster/signer/developer_managed",
        configuration.base_path
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("public_key", &params.public_key.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeveloperManagedSigner`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeveloperManagedSigner`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<LookupDeveloperManagedSignerError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Gets information status of a signer by passing in a signer_uuid (Use post API to generate a signer)
pub async fn lookup_signer(
    configuration: &configuration::Configuration,
    params: LookupSignerParams,
) -> Result<models::Signer, Error<LookupSignerError>> {
    let uri_str = format!("{}/farcaster/signer", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("signer_uuid", &params.signer_uuid.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Signer`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Signer`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<LookupSignerError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Publish a message to farcaster. The message must be signed by a signer managed by the developer. Use the @farcaster/core library to construct and sign the message. Use the Message.toJSON method on the signed message and pass the JSON in the body of this POST request.
pub async fn publish_message_to_farcaster(
    configuration: &configuration::Configuration,
    params: PublishMessageToFarcasterParams,
) -> Result<serde_json::Value, Error<PublishMessageToFarcasterError>> {
    let uri_str = format!("{}/farcaster/message", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };
    req_builder = req_builder.header(reqwest::header::CONTENT_TYPE, "application/json");
    req_builder = req_builder.json(&params.body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PublishMessageToFarcasterError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Registers an app FID, deadline and a signature. Returns the signer status with an approval url.
pub async fn register_signed_key(
    configuration: &configuration::Configuration,
    params: RegisterSignedKeyParams,
) -> Result<models::Signer, Error<RegisterSignedKeyError>> {
    let uri_str = format!("{}/farcaster/signer/signed_key", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };
    req_builder = req_builder.header(reqwest::header::CONTENT_TYPE, "application/json");
    req_builder = req_builder.json(&params.register_signer_key_req_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Signer`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Signer`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RegisterSignedKeyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Registers an signed key and returns the developer managed signer status with an approval url.
pub async fn register_signed_key_for_developer_managed_signer(
    configuration: &configuration::Configuration,
    params: RegisterSignedKeyForDeveloperManagedSignerParams,
) -> Result<models::DeveloperManagedSigner, Error<RegisterSignedKeyForDeveloperManagedSignerError>>
{
    let uri_str = format!(
        "{}/farcaster/signer/developer_managed/signed_key",
        configuration.base_path
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };
    req_builder = req_builder.header(reqwest::header::CONTENT_TYPE, "application/json");
    req_builder = req_builder.json(&params.register_developer_managed_signed_key_req_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeveloperManagedSigner`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeveloperManagedSigner`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RegisterSignedKeyForDeveloperManagedSignerError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
