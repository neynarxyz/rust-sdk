/*
 * Farcaster API V2
 *
 * The Farcaster API allows you to interact with the Farcaster protocol. See the [Neynar docs](https://docs.neynar.com/reference) for more details. 
 *
 * The version of the OpenAPI document: 2.33.1
 * Contact: team@neynar.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`fetch_casts_for_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchCastsForUserError {
    Status400(models::ErrorRes),
    Status500(models::ErrorRes),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_feed`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchFeedError {
    Status400(models::ErrorRes),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_feed_by_channel_ids`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchFeedByChannelIdsError {
    Status400(models::ErrorRes),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_feed_by_parent_urls`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchFeedByParentUrlsError {
    Status400(models::ErrorRes),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_feed_for_you`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchFeedForYouError {
    Status400(models::FetchFeedForYou400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_frames_only_feed`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchFramesOnlyFeedError {
    Status400(models::ErrorRes),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_popular_casts_by_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchPopularCastsByUserError {
    Status400(models::ErrorRes),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_replies_and_recasts_for_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchRepliesAndRecastsForUserError {
    Status400(models::ErrorRes),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_trending_feed`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchTrendingFeedError {
    Status400(models::FetchTrendingFeed400Response),
    Status404(models::ErrorRes),
    Status500(models::ErrorRes),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_user_following_feed`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchUserFollowingFeedError {
    Status400(models::ErrorRes),
    UnknownValue(serde_json::Value),
}


/// Fetch casts for a given user FID in reverse chronological order. Also allows filtering by parent_url and channel
pub async fn fetch_casts_for_user(configuration: &configuration::Configuration, fid: i32, app_fid: Option<i32>, viewer_fid: Option<i32>, limit: Option<i32>, cursor: Option<&str>, include_replies: Option<bool>, parent_url: Option<&str>, channel_id: Option<&str>, x_neynar_experimental: Option<bool>) -> Result<models::FeedResponse, Error<FetchCastsForUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_fid = fid;
    let p_app_fid = app_fid;
    let p_viewer_fid = viewer_fid;
    let p_limit = limit;
    let p_cursor = cursor;
    let p_include_replies = include_replies;
    let p_parent_url = parent_url;
    let p_channel_id = channel_id;
    let p_x_neynar_experimental = x_neynar_experimental;

    let uri_str = format!("{}/farcaster/feed/user/casts", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("fid", &p_fid.to_string())]);
    if let Some(ref param_value) = p_app_fid {
        req_builder = req_builder.query(&[("app_fid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_viewer_fid {
        req_builder = req_builder.query(&[("viewer_fid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_cursor {
        req_builder = req_builder.query(&[("cursor", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_replies {
        req_builder = req_builder.query(&[("include_replies", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_parent_url {
        req_builder = req_builder.query(&[("parent_url", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_channel_id {
        req_builder = req_builder.query(&[("channel_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_neynar_experimental {
        req_builder = req_builder.header("x-neynar-experimental", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FeedResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FeedResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FetchCastsForUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch casts based on filters. Ensure setting the correct parameters based on the feed_type and filter_type.
pub async fn fetch_feed(configuration: &configuration::Configuration, feed_type: models::FeedType, filter_type: Option<models::FilterType>, fid: Option<i32>, fids: Option<&str>, parent_url: Option<&str>, channel_id: Option<&str>, members_only: Option<bool>, embed_url: Option<&str>, embed_types: Option<Vec<models::EmbedType>>, with_recasts: Option<bool>, limit: Option<i32>, cursor: Option<&str>, viewer_fid: Option<i32>, x_neynar_experimental: Option<bool>) -> Result<models::FeedResponse, Error<FetchFeedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_feed_type = feed_type;
    let p_filter_type = filter_type;
    let p_fid = fid;
    let p_fids = fids;
    let p_parent_url = parent_url;
    let p_channel_id = channel_id;
    let p_members_only = members_only;
    let p_embed_url = embed_url;
    let p_embed_types = embed_types;
    let p_with_recasts = with_recasts;
    let p_limit = limit;
    let p_cursor = cursor;
    let p_viewer_fid = viewer_fid;
    let p_x_neynar_experimental = x_neynar_experimental;

    let uri_str = format!("{}/farcaster/feed", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("feed_type", &p_feed_type.to_string())]);
    if let Some(ref param_value) = p_filter_type {
        req_builder = req_builder.query(&[("filter_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_fid {
        req_builder = req_builder.query(&[("fid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_fids {
        req_builder = req_builder.query(&[("fids", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_parent_url {
        req_builder = req_builder.query(&[("parent_url", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_channel_id {
        req_builder = req_builder.query(&[("channel_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_members_only {
        req_builder = req_builder.query(&[("members_only", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_embed_url {
        req_builder = req_builder.query(&[("embed_url", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_embed_types {
        req_builder = match "csv" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("embed_types".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("embed_types", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_with_recasts {
        req_builder = req_builder.query(&[("with_recasts", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_cursor {
        req_builder = req_builder.query(&[("cursor", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_viewer_fid {
        req_builder = req_builder.query(&[("viewer_fid", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_neynar_experimental {
        req_builder = req_builder.header("x-neynar-experimental", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FeedResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FeedResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FetchFeedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch feed based on channel IDs
pub async fn fetch_feed_by_channel_ids(configuration: &configuration::Configuration, channel_ids: &str, with_recasts: Option<bool>, viewer_fid: Option<i32>, with_replies: Option<bool>, members_only: Option<bool>, fids: Option<&str>, limit: Option<i32>, cursor: Option<&str>, should_moderate: Option<bool>, x_neynar_experimental: Option<bool>) -> Result<models::FeedResponse, Error<FetchFeedByChannelIdsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_channel_ids = channel_ids;
    let p_with_recasts = with_recasts;
    let p_viewer_fid = viewer_fid;
    let p_with_replies = with_replies;
    let p_members_only = members_only;
    let p_fids = fids;
    let p_limit = limit;
    let p_cursor = cursor;
    let p_should_moderate = should_moderate;
    let p_x_neynar_experimental = x_neynar_experimental;

    let uri_str = format!("{}/farcaster/feed/channels", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("channel_ids", &p_channel_ids.to_string())]);
    if let Some(ref param_value) = p_with_recasts {
        req_builder = req_builder.query(&[("with_recasts", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_viewer_fid {
        req_builder = req_builder.query(&[("viewer_fid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_with_replies {
        req_builder = req_builder.query(&[("with_replies", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_members_only {
        req_builder = req_builder.query(&[("members_only", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_fids {
        req_builder = req_builder.query(&[("fids", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_cursor {
        req_builder = req_builder.query(&[("cursor", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_should_moderate {
        req_builder = req_builder.query(&[("should_moderate", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_neynar_experimental {
        req_builder = req_builder.header("x-neynar-experimental", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FeedResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FeedResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FetchFeedByChannelIdsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch feed based on parent URLs
pub async fn fetch_feed_by_parent_urls(configuration: &configuration::Configuration, parent_urls: &str, with_recasts: Option<bool>, viewer_fid: Option<i32>, with_replies: Option<bool>, limit: Option<i32>, cursor: Option<&str>, x_neynar_experimental: Option<bool>) -> Result<models::FeedResponse, Error<FetchFeedByParentUrlsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_parent_urls = parent_urls;
    let p_with_recasts = with_recasts;
    let p_viewer_fid = viewer_fid;
    let p_with_replies = with_replies;
    let p_limit = limit;
    let p_cursor = cursor;
    let p_x_neynar_experimental = x_neynar_experimental;

    let uri_str = format!("{}/farcaster/feed/parent_urls", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("parent_urls", &p_parent_urls.to_string())]);
    if let Some(ref param_value) = p_with_recasts {
        req_builder = req_builder.query(&[("with_recasts", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_viewer_fid {
        req_builder = req_builder.query(&[("viewer_fid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_with_replies {
        req_builder = req_builder.query(&[("with_replies", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_cursor {
        req_builder = req_builder.query(&[("cursor", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_neynar_experimental {
        req_builder = req_builder.header("x-neynar-experimental", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FeedResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FeedResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FetchFeedByParentUrlsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch a personalized For You feed for a user
pub async fn fetch_feed_for_you(configuration: &configuration::Configuration, fid: i32, viewer_fid: Option<i32>, provider: Option<models::ForYouProvider>, limit: Option<i32>, cursor: Option<&str>, provider_metadata: Option<&str>, x_neynar_experimental: Option<bool>) -> Result<models::FeedResponse, Error<FetchFeedForYouError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_fid = fid;
    let p_viewer_fid = viewer_fid;
    let p_provider = provider;
    let p_limit = limit;
    let p_cursor = cursor;
    let p_provider_metadata = provider_metadata;
    let p_x_neynar_experimental = x_neynar_experimental;

    let uri_str = format!("{}/farcaster/feed/for_you", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("fid", &p_fid.to_string())]);
    if let Some(ref param_value) = p_viewer_fid {
        req_builder = req_builder.query(&[("viewer_fid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_provider {
        req_builder = req_builder.query(&[("provider", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_cursor {
        req_builder = req_builder.query(&[("cursor", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_provider_metadata {
        req_builder = req_builder.query(&[("provider_metadata", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_neynar_experimental {
        req_builder = req_builder.header("x-neynar-experimental", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FeedResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FeedResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FetchFeedForYouError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch feed of casts with mini apps, reverse chronological order
pub async fn fetch_frames_only_feed(configuration: &configuration::Configuration, limit: Option<i32>, viewer_fid: Option<i32>, cursor: Option<&str>, x_neynar_experimental: Option<bool>) -> Result<models::FeedResponse, Error<FetchFramesOnlyFeedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_limit = limit;
    let p_viewer_fid = viewer_fid;
    let p_cursor = cursor;
    let p_x_neynar_experimental = x_neynar_experimental;

    let uri_str = format!("{}/farcaster/feed/frames", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_viewer_fid {
        req_builder = req_builder.query(&[("viewer_fid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_cursor {
        req_builder = req_builder.query(&[("cursor", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_neynar_experimental {
        req_builder = req_builder.header("x-neynar-experimental", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FeedResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FeedResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FetchFramesOnlyFeedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch 10 most popular casts for a given user FID; popularity based on replies, likes and recasts; sorted by most popular first
pub async fn fetch_popular_casts_by_user(configuration: &configuration::Configuration, fid: i32, viewer_fid: Option<i32>) -> Result<models::BulkCastsResponse, Error<FetchPopularCastsByUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_fid = fid;
    let p_viewer_fid = viewer_fid;

    let uri_str = format!("{}/farcaster/feed/user/popular", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("fid", &p_fid.to_string())]);
    if let Some(ref param_value) = p_viewer_fid {
        req_builder = req_builder.query(&[("viewer_fid", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BulkCastsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BulkCastsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FetchPopularCastsByUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch recent replies and recasts for a given user FID; sorted by most recent first
pub async fn fetch_replies_and_recasts_for_user(configuration: &configuration::Configuration, fid: i32, filter: Option<&str>, limit: Option<i32>, cursor: Option<&str>, viewer_fid: Option<i32>) -> Result<models::FeedResponse, Error<FetchRepliesAndRecastsForUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_fid = fid;
    let p_filter = filter;
    let p_limit = limit;
    let p_cursor = cursor;
    let p_viewer_fid = viewer_fid;

    let uri_str = format!("{}/farcaster/feed/user/replies_and_recasts", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("fid", &p_fid.to_string())]);
    if let Some(ref param_value) = p_filter {
        req_builder = req_builder.query(&[("filter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_cursor {
        req_builder = req_builder.query(&[("cursor", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_viewer_fid {
        req_builder = req_builder.query(&[("viewer_fid", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FeedResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FeedResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FetchRepliesAndRecastsForUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch trending casts or on the global feed or channels feeds. 7d time window available for channel feeds only.
pub async fn fetch_trending_feed(configuration: &configuration::Configuration, limit: Option<i32>, cursor: Option<&str>, viewer_fid: Option<i32>, time_window: Option<models::TrendingTimeWindow>, channel_id: Option<&str>, parent_url: Option<&str>, provider: Option<models::FeedTrendingProvider>, provider_metadata: Option<&str>, x_neynar_experimental: Option<bool>) -> Result<models::FeedResponse, Error<FetchTrendingFeedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_limit = limit;
    let p_cursor = cursor;
    let p_viewer_fid = viewer_fid;
    let p_time_window = time_window;
    let p_channel_id = channel_id;
    let p_parent_url = parent_url;
    let p_provider = provider;
    let p_provider_metadata = provider_metadata;
    let p_x_neynar_experimental = x_neynar_experimental;

    let uri_str = format!("{}/farcaster/feed/trending", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_cursor {
        req_builder = req_builder.query(&[("cursor", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_viewer_fid {
        req_builder = req_builder.query(&[("viewer_fid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_time_window {
        req_builder = req_builder.query(&[("time_window", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_channel_id {
        req_builder = req_builder.query(&[("channel_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_parent_url {
        req_builder = req_builder.query(&[("parent_url", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_provider {
        req_builder = req_builder.query(&[("provider", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_provider_metadata {
        req_builder = req_builder.query(&[("provider_metadata", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_neynar_experimental {
        req_builder = req_builder.header("x-neynar-experimental", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FeedResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FeedResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FetchTrendingFeedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch feed based on who a user is following
pub async fn fetch_user_following_feed(configuration: &configuration::Configuration, fid: i32, viewer_fid: Option<i32>, with_recasts: Option<bool>, limit: Option<i32>, cursor: Option<&str>, x_neynar_experimental: Option<bool>) -> Result<models::FeedResponse, Error<FetchUserFollowingFeedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_fid = fid;
    let p_viewer_fid = viewer_fid;
    let p_with_recasts = with_recasts;
    let p_limit = limit;
    let p_cursor = cursor;
    let p_x_neynar_experimental = x_neynar_experimental;

    let uri_str = format!("{}/farcaster/feed/following", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("fid", &p_fid.to_string())]);
    if let Some(ref param_value) = p_viewer_fid {
        req_builder = req_builder.query(&[("viewer_fid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_with_recasts {
        req_builder = req_builder.query(&[("with_recasts", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_cursor {
        req_builder = req_builder.query(&[("cursor", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_x_neynar_experimental {
        req_builder = req_builder.header("x-neynar-experimental", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FeedResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FeedResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FetchUserFollowingFeedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

