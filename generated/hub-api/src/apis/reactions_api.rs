/*
 * Farcaster Hub API
 *
 * Perform basic queries of Farcaster state via the REST API of a Farcaster hub. See the [Neynar docs](https://docs.neynar.com/reference) for more details.
 *
 * The version of the OpenAPI document: 2.21.0
 * Contact: team@neynar.com
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for passing parameters to the method [`fetch_cast_reactions`]
#[derive(Clone, Debug)]
pub struct FetchCastReactionsParams {
    /// The FID of the cast's creator. Required to uniquely identify the cast that received the reactions. Must be used in conjunction with target_hash.
    pub target_fid: i32,
    /// The unique hash identifier of the cast that received the reactions. This is a 40-character hexadecimal string prefixed with '0x' that uniquely identifies the cast within the creator's posts. Must be used with target_fid.
    pub target_hash: String,
    pub reaction_type: models::ReactionType,
    /// Maximum number of messages to return in a single response
    pub page_size: Option<i32>,
    /// Reverse the sort order, returning latest messages first
    pub reverse: Option<bool>,
    /// The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page
    pub page_token: Option<String>,
}

/// struct for passing parameters to the method [`fetch_reactions_by_target`]
#[derive(Clone, Debug)]
pub struct FetchReactionsByTargetParams {
    /// Target URL starting with 'chain://'.
    pub url: String,
    pub reaction_type: Option<models::ReactionType>,
    /// Maximum number of messages to return in a single response
    pub page_size: Option<i32>,
    /// Reverse the sort order, returning latest messages first
    pub reverse: Option<bool>,
    /// The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page
    pub page_token: Option<String>,
}

/// struct for passing parameters to the method [`fetch_user_reactions`]
#[derive(Clone, Debug)]
pub struct FetchUserReactionsParams {
    /// The FID of the reaction's creator
    pub fid: i32,
    pub reaction_type: models::ReactionType,
    /// Maximum number of messages to return in a single response
    pub page_size: Option<i32>,
    /// Reverse the sort order, returning latest messages first
    pub reverse: Option<bool>,
    /// The page token returned by the previous query, to fetch the next page. If this parameter is empty, fetch the first page
    pub page_token: Option<String>,
}

/// struct for passing parameters to the method [`lookup_reaction_by_id`]
#[derive(Clone, Debug)]
pub struct LookupReactionByIdParams {
    /// The FID of the reaction's creator
    pub fid: i32,
    /// The FID of the cast's creator
    pub target_fid: i32,
    /// The cast's hash
    pub target_hash: String,
    pub reaction_type: models::ReactionType,
}

/// struct for typed errors of method [`fetch_cast_reactions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchCastReactionsError {
    DefaultResponse(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_reactions_by_target`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchReactionsByTargetError {
    DefaultResponse(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_user_reactions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchUserReactionsError {
    DefaultResponse(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`lookup_reaction_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LookupReactionByIdError {
    DefaultResponse(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// Retrieve all reactions (likes or recasts) on a specific cast in the Farcaster network. The cast is identified by its creator's FID and unique hash. This endpoint helps track engagement metrics and user interactions with specific content.
pub async fn fetch_cast_reactions(
    configuration: &configuration::Configuration,
    params: FetchCastReactionsParams,
) -> Result<models::FetchCastReactions200Response, Error<FetchCastReactionsError>> {
    let uri_str = format!("{}/v1/reactionsByCast", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("target_fid", &params.target_fid.to_string())]);
    req_builder = req_builder.query(&[("target_hash", &params.target_hash.to_string())]);
    req_builder = req_builder.query(&[("reaction_type", &params.reaction_type.to_string())]);
    if let Some(ref param_value) = params.page_size {
        req_builder = req_builder.query(&[("pageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.reverse {
        req_builder = req_builder.query(&[("reverse", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page_token {
        req_builder = req_builder.query(&[("pageToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FetchCastReactions200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FetchCastReactions200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FetchCastReactionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Fetch all reactions of a specific type (like or recast) that target a given URL. This endpoint is useful for tracking engagement with content across the Farcaster network.
pub async fn fetch_reactions_by_target(
    configuration: &configuration::Configuration,
    params: FetchReactionsByTargetParams,
) -> Result<models::FetchReactionsByTarget200Response, Error<FetchReactionsByTargetError>> {
    let uri_str = format!("{}/v1/reactionsByTarget", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("url", &params.url.to_string())]);
    if let Some(ref param_value) = params.reaction_type {
        req_builder = req_builder.query(&[("reaction_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page_size {
        req_builder = req_builder.query(&[("pageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.reverse {
        req_builder = req_builder.query(&[("reverse", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page_token {
        req_builder = req_builder.query(&[("pageToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FetchReactionsByTarget200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FetchReactionsByTarget200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FetchReactionsByTargetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Fetch reactions by a user.
pub async fn fetch_user_reactions(
    configuration: &configuration::Configuration,
    params: FetchUserReactionsParams,
) -> Result<models::FetchUserReactions200Response, Error<FetchUserReactionsError>> {
    let uri_str = format!("{}/v1/reactionsByFid", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("fid", &params.fid.to_string())]);
    req_builder = req_builder.query(&[("reaction_type", &params.reaction_type.to_string())]);
    if let Some(ref param_value) = params.page_size {
        req_builder = req_builder.query(&[("pageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.reverse {
        req_builder = req_builder.query(&[("reverse", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page_token {
        req_builder = req_builder.query(&[("pageToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FetchUserReactions200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FetchUserReactions200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FetchUserReactionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Lookup a reaction by its FID or cast.
pub async fn lookup_reaction_by_id(
    configuration: &configuration::Configuration,
    params: LookupReactionByIdParams,
) -> Result<models::Reaction, Error<LookupReactionByIdError>> {
    let uri_str = format!("{}/v1/reactionById", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("fid", &params.fid.to_string())]);
    req_builder = req_builder.query(&[("target_fid", &params.target_fid.to_string())]);
    req_builder = req_builder.query(&[("target_hash", &params.target_hash.to_string())]);
    req_builder = req_builder.query(&[("reaction_type", &params.reaction_type.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Reaction`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Reaction`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<LookupReactionByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
