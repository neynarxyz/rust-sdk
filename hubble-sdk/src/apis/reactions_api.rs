/*
 * Farcaster Hub API
 *
 * Perform basic queries of Farcaster state via the REST API of a Farcaster hub. See the [Neynar docs](https://docs.neynar.com/reference) for more details. 
 *
 * The version of the OpenAPI document: 2.21.0
 * Contact: team@neynar.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`fetch_cast_reactions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchCastReactionsError {
    DefaultResponse(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_reactions_by_target`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchReactionsByTargetError {
    DefaultResponse(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_user_reactions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchUserReactionsError {
    DefaultResponse(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`lookup_reaction_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LookupReactionByIdError {
    DefaultResponse(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}


/// Retrieve all reactions (likes or recasts) on a specific cast in the Farcaster network. The cast is identified by its creator's FID and unique hash. This endpoint helps track engagement metrics and user interactions with specific content.
pub async fn fetch_cast_reactions(configuration: &configuration::Configuration, target_fid: i32, target_hash: &str, reaction_type: models::ReactionType, page_size: Option<i32>, reverse: Option<bool>, page_token: Option<&str>) -> Result<models::FetchCastReactions200Response, Error<FetchCastReactionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_target_fid = target_fid;
    let p_target_hash = target_hash;
    let p_reaction_type = reaction_type;
    let p_page_size = page_size;
    let p_reverse = reverse;
    let p_page_token = page_token;

    let uri_str = format!("{}/v1/reactionsByCast", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("target_fid", &p_target_fid.to_string())]);
    req_builder = req_builder.query(&[("target_hash", &p_target_hash.to_string())]);
    req_builder = req_builder.query(&[("reaction_type", &p_reaction_type.to_string())]);
    if let Some(ref param_value) = p_page_size {
        req_builder = req_builder.query(&[("pageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_reverse {
        req_builder = req_builder.query(&[("reverse", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_token {
        req_builder = req_builder.query(&[("pageToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FetchCastReactions200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FetchCastReactions200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FetchCastReactionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch all reactions of a specific type (like or recast) that target a given URL. This endpoint is useful for tracking engagement with content across the Farcaster network.
pub async fn fetch_reactions_by_target(configuration: &configuration::Configuration, url: &str, reaction_type: Option<models::ReactionType>, page_size: Option<i32>, reverse: Option<bool>, page_token: Option<&str>) -> Result<models::FetchCastReactions200Response, Error<FetchReactionsByTargetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_url = url;
    let p_reaction_type = reaction_type;
    let p_page_size = page_size;
    let p_reverse = reverse;
    let p_page_token = page_token;

    let uri_str = format!("{}/v1/reactionsByTarget", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("url", &p_url.to_string())]);
    if let Some(ref param_value) = p_reaction_type {
        req_builder = req_builder.query(&[("reaction_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_size {
        req_builder = req_builder.query(&[("pageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_reverse {
        req_builder = req_builder.query(&[("reverse", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_token {
        req_builder = req_builder.query(&[("pageToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FetchCastReactions200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FetchCastReactions200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FetchReactionsByTargetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch reactions by a user.
pub async fn fetch_user_reactions(configuration: &configuration::Configuration, fid: i32, reaction_type: models::ReactionType, page_size: Option<i32>, reverse: Option<bool>, page_token: Option<&str>) -> Result<models::FetchCastReactions200Response, Error<FetchUserReactionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_fid = fid;
    let p_reaction_type = reaction_type;
    let p_page_size = page_size;
    let p_reverse = reverse;
    let p_page_token = page_token;

    let uri_str = format!("{}/v1/reactionsByFid", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("fid", &p_fid.to_string())]);
    req_builder = req_builder.query(&[("reaction_type", &p_reaction_type.to_string())]);
    if let Some(ref param_value) = p_page_size {
        req_builder = req_builder.query(&[("pageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_reverse {
        req_builder = req_builder.query(&[("reverse", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_token {
        req_builder = req_builder.query(&[("pageToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FetchCastReactions200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FetchCastReactions200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FetchUserReactionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lookup a reaction by its FID or cast.
pub async fn lookup_reaction_by_id(configuration: &configuration::Configuration, fid: i32, target_fid: i32, target_hash: &str, reaction_type: models::ReactionType) -> Result<models::Reaction, Error<LookupReactionByIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_fid = fid;
    let p_target_fid = target_fid;
    let p_target_hash = target_hash;
    let p_reaction_type = reaction_type;

    let uri_str = format!("{}/v1/reactionById", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("fid", &p_fid.to_string())]);
    req_builder = req_builder.query(&[("target_fid", &p_target_fid.to_string())]);
    req_builder = req_builder.query(&[("target_hash", &p_target_hash.to_string())]);
    req_builder = req_builder.query(&[("reaction_type", &p_reaction_type.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("x-api-key", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Reaction`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Reaction`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<LookupReactionByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

